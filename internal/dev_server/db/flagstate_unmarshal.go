package db

import (
	"encoding/json"

	"github.com/launchdarkly/go-sdk-common/v3/ldvalue"
	"github.com/launchdarkly/go-server-sdk/v7/interfaces/flagstate"
	"github.com/pkg/errors"
)

type partialFlagState struct {
	Version int `json:"version"`
}

// UnmarshalFlagStateJSON unmarshals JSON generated by flagstate.AllFlags.MarshalJSON
// Simplified to exclude things that we don't care about. All we need are versions here.
func UnmarshalFlagStateJSON(jsonBytes []byte) (flagstate.AllFlags, error) {
	var loose map[string]json.RawMessage
	err := json.Unmarshal(jsonBytes, &loose)
	if err != nil {
		return flagstate.AllFlags{}, errors.Wrap(err, "unable to all flags")
	}
	validJson, ok := loose["$valid"]
	if !ok {
		return flagstate.AllFlags{}, errors.New("$valid not found in flag state")
	}
	var isValid bool
	err = json.Unmarshal(validJson, &isValid)
	if err != nil {
		return flagstate.AllFlags{}, errors.Wrap(err, "unable to unmarshal validness from all flags")
	}
	if !isValid {
		return flagstate.AllFlags{}, errors.New("invalid flag state")
	}
	delete(loose, "$valid")
	flagStateJson, ok := loose["$flagsState"]
	if !ok {
		return flagstate.AllFlags{}, errors.New("$flagsState not found in flag state")
	}
	delete(loose, "$flagsState")

	var flagStateMap map[string]partialFlagState
	err = json.Unmarshal(flagStateJson, &flagStateMap)
	if err != nil {
		return flagstate.AllFlags{}, errors.Wrap(err, "unable to unmarshal flag state")
	}

	allFlagsBuilder := flagstate.NewAllFlagsBuilder()
	for flagKey, valueJson := range loose {
		var ldValue ldvalue.Value
		err := json.Unmarshal(valueJson, &ldValue)
		if err != nil {
			return flagstate.AllFlags{}, errors.Wrapf(err, "unable to unmarshal flag value for flag %s", flagKey)
		}
		allFlagsBuilder.AddFlag(flagKey, flagstate.FlagState{
			Value:   ldValue,
			Version: flagStateMap[flagKey].Version,
		})
	}
	return allFlagsBuilder.Build(), nil
}
